<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_20) on Sun Jan 27 19:19:33 EST 2013 -->
<TITLE>
JsonAvroBinding (Oracle NoSQL Database API)
</TITLE>

<META NAME="date" CONTENT="2013-01-27">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../style.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JsonAvroBinding (Oracle NoSQL Database API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JsonAvroBinding.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Oracle NoSQL Database</b><br><font size=\"-1\"> version 11gR2.2.0.26</font>
      </EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../oracle/kv/avro/GenericAvroBinding.html" title="interface in oracle.kv.avro"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?oracle/kv/avro/JsonAvroBinding.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JsonAvroBinding.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
oracle.kv.avro</FONT>
<BR>
Interface JsonAvroBinding</H2>
<DL>
<DT><B>All Superinterfaces:</B> <DD><A HREF="../../../oracle/kv/avro/AvroBinding.html" title="interface in oracle.kv.avro">AvroBinding</A>&lt;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A>&gt;, <A HREF="../../../oracle/kv/ValueBinding.html" title="interface in oracle.kv">ValueBinding</A>&lt;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A>&gt;</DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>JsonAvroBinding</B><DT>extends <A HREF="../../../oracle/kv/avro/AvroBinding.html" title="interface in oracle.kv.avro">AvroBinding</A>&lt;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A>&gt;</DL>
</PRE>

<P>
The <code>JsonAvroBinding</code> interface has the same methods as <A HREF="../../../oracle/kv/avro/AvroBinding.html" title="interface in oracle.kv.avro"><CODE>AvroBinding</CODE></A>, but represents values as instances of <A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><CODE>JsonRecord</CODE></A>.
 A single schema binding is created using <A HREF="../../../oracle/kv/avro/AvroCatalog.html#getJsonBinding(org.apache.avro.Schema)"><CODE>AvroCatalog.getJsonBinding(org.apache.avro.Schema)</CODE></A>, and a multiple schema binding is created
 using <A HREF="../../../oracle/kv/avro/AvroCatalog.html#getJsonMultiBinding(java.util.Map)"><CODE>AvroCatalog.getJsonMultiBinding(java.util.Map<java.lang.String, org.apache.avro.Schema>)</CODE></A>.
 <p>
 The trade-offs in using a <code>JsonAvroBinding</code>, compared to other types
 of bindings, are:
   <ul>
   <li>Probably the most important reason for using a JSON binding is for
   interoperability with other components or external systems that use JSON
   objects.
   <p></li>
   <li>Like generic bindings, an advantage of using a JSON binding is that
   values may be treated generically.  Also, if schemas are treated
   dynamically, then the set of schemas used in the application need not be
   fixed at build time.
   <p></li>
   <li>Unlike <A HREF="http://avro.apache.org/docs/1.6.3/api/java/org/apache/avro/generic/GenericRecord.html?is-external=true" title="class or interface in org.apache.avro.generic"><CODE>GenericRecord</CODE></A>, certain Avro data types are not
   represented conveniently using JSON syntax, namely:
     <ul>
     <li>Avro <code>int</code> and <code>long</code> are both represented as a JSON
     <code>integer</code>, and Avro <code>float</code> and <code>double</code> are both
     represented as a JSON <code>number</code>.  WARNING: To avoid type conversion
     errors, consider defining integer fields in the Avro schema using type
     <code>long</code>, and floating point fields using type <code>double</code>.</li>
     <li>Avro <code>bytes</code> and <code>fixed</code> are both represented as a
     JSON <code>string</code>, using Unicode escape syntax.  WARNING: Characters
     greater than <code>0xFF</code> are invalid because they cannot be translated
     to bytes without loss of information.  Also note that the Jackson
     <A HREF="http://jackson.codehaus.org/1.8.8/javadoc/org/codehaus/jackson/node/BinaryNode.html?is-external=true" title="class or interface in org.codehaus.jackson.node"><CODE>BinaryNode</CODE></A> class is <em>not</em>
     used with these Avro types.</li>
     <li>Avro unions have a <a
 href="http://avro.apache.org/docs/current/spec.html#json_encoding">special
      JSON representation</a>.</li>
     </ul>
   Therefore, applications using JSON should limit the data types used in
   their Avro schemas, and should treat the above data types carefully.
   <p>
   Also note the following type mappings:
     <ul>
     <li>Avro <code>record</code> and <code>map</code> are both represented as a JSON
     <code>object</code>.</li>
     <li>An Avro <code>enum</code> is represented as a JSON <code>string</code>.</li>
     </ul>
   <p></li>
   <li>Like a <A HREF="http://avro.apache.org/docs/1.6.3/api/java/org/apache/avro/generic/GenericRecord.html?is-external=true" title="class or interface in org.apache.avro.generic"><CODE>GenericRecord</CODE></A>, a JSON object does not provide type
   safety.  It can also be error prone, because fields are accessed by
   string name.
   <p></li>
   <li>To support class evolution, with JSON bindings (like generic
   bindings, but unlike specific bindings) the application must supply the
   Avro <A HREF="http://avro.apache.org/docs/1.6.3/api/java/org/apache/avro/Schema.html?is-external=true" title="class or interface in org.apache.avro"><CODE>Schema</CODE></A> objects at runtime.  In other words, the application
   must maintain a set of known schemas for use at runtime.
   <p></li>
   </ul>
 <p>
 See <A HREF="../../../oracle/kv/avro/AvroCatalog.html" title="interface in oracle.kv.avro"><CODE>AvroCatalog</CODE></A> for general information on Avro bindings and
 schemas.  The schemas used in the examples below are described in the <A HREF="../../../oracle/kv/avro/AvroCatalog.html" title="interface in oracle.kv.avro"><CODE>AvroCatalog</CODE></A> javadoc.
 <p>
 When using a <code>JsonAvroBinding</code>, a <A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><CODE>JsonRecord</CODE></A> is used to
 represent values.  A <A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><CODE>JsonRecord</CODE></A> represents an Avro object as an
 <A HREF="http://jackson.codehaus.org/1.8.8/javadoc/org/codehaus/jackson/JsonNode.html?is-external=true" title="class or interface in org.codehaus.jackson"><CODE>JsonNode</CODE></A> in the Jackson API.
 <p>
 As with a generic binding, a <A HREF="http://jackson.codehaus.org/1.8.8/javadoc/org/codehaus/jackson/JsonNode.html?is-external=true" title="class or interface in org.codehaus.jackson"><CODE>JsonNode</CODE></A> represents an Avro object
 roughly as a map of string field names to field values.  However, the
 Jackson API is very rich and fully supports the JSON format.  For those
 familiar with XML, the Jackson API is for JSON what the DOM API is for XML.
 JSON text may also be easily parsed and formatted using the Jackson API.
 <p>
 The following code fragment demonstrates writing and reading a value using a
 JSON single schema binding.

 <pre class="code">
 Schema.Parser parser = new Schema.Parser();
 Schema nameSchema = parser.parse(nameSchemaText);
 Schema memberSchema = parser.parse(memberSchemaText);

 JsonAvroBinding binding = avroCatalog.getJsonBinding(memberSchema);

 // Create object
 ObjectNode member = JsonNodeFactory.instance.objectNode();
 JsonRecord object = new JsonRecord(member, memberSchema)
 ObjectNode name = member.putObject("name");
 name.put("first", ...);
 name.put("last", ...);
 member.put("age", ...);

 // Serialize and store
 Value value = binding.toValue(object);
 kvStore.put(key, value);

 // Sometime later, retrieve and deserialize
 ValueVersion vv = kvStore.get(key);
 JsonRecord object = binding.toObject(vv.getValue());

 // Use object
 ObjectNode member = (ObjectNode) object.getNode();
 ObjectNode name = (ObjectNode) member.get("name");
 int age = member.get("age").getIntValue();
 ...</pre>
 <p>
 The following code fragment demonstrates reading values with different
 schemas using a JSON multiple schema binding.

 <pre class="code">
 Schema.Parser parser = new Schema.Parser();
 Schema nameSchema = parser.parse(nameSchemaText);
 Schema memberSchema = parser.parse(memberSchemaText);
 Schema anotherSchema = parser.parse(anotherSchemaText);

 Map&lt;String, Schema&gt; schemas = new HashMap&lt;String, Schema&gt;()
 schemas.put(memberSchema.getFullName(), memberSchema);
 schemas.put(anotherSchema.getFullName(), anotherSchema);

 JsonAvroBinding binding = avroCatalog.getJsonMultiBinding(schemas);

 Iterator&lt;KeyValueVersion&gt; iter = kvStore.multiGetIterator(...);
 for (KeyValueVersion kvv : iter) {
     JsonRecord object = binding.toObject(kvv.getValue());
     JsonNode jsonNode = object.getJsonNode();
     String schemaName = object.getSchema().getFullName();
     if (schemaName.equals(memberSchema.getFullName())) {
         ...
     } else if (schemaName.equals(anotherSchema.getFullName())) {
         ...
     } else {
         ...
     }
 }</pre>
 <p>
 A special use case for a JSON multiple schema binding is when the
 application treats values dynamically based on their schema, rather than
 using a fixed set of known schemas.  The <A HREF="../../../oracle/kv/avro/AvroCatalog.html#getCurrentSchemas()"><CODE>AvroCatalog.getCurrentSchemas()</CODE></A> method can be used to obtain a map of the
 most current schemas,  which can be passed to <A HREF="../../../oracle/kv/avro/AvroCatalog.html#getJsonMultiBinding(java.util.Map)"><CODE>AvroCatalog.getJsonMultiBinding(java.util.Map<java.lang.String, org.apache.avro.Schema>)</CODE></A>.
 <p>
 For example, the following code fragment demonstrates reading values with
 different schemas using a JSON multiple schema binding.  Note that in a long
 running application, it is possible that a schema may be added and used to
 store a key-value pair, after the binding has been created.  The application
 may handle this possibility by catching <A HREF="../../../oracle/kv/avro/SchemaNotAllowedException.html" title="class in oracle.kv.avro"><CODE>SchemaNotAllowedException</CODE></A>.

 <pre class="code">
 JsonAvroBinding binding =
     avroCatalog.getJsonMultiBinding(avroCatalog.getCurrentSchemas());

 Iterator&lt;KeyValueVersion&gt; iter = kvStore.storeIterator(...);
 for (KeyValueVersion kvv : iter) {
     JsonRecord object;
     try {
         object = binding.toObject(kvv.getValue());
     } catch (SchemaNotAllowedException e) {
         // In this example, ignore values with a schema that was not
         // known at the time the binding was created.
         continue;
     }
     JsonNode jsonNode = object.getJsonNode();
     String schemaName = object.getSchema().getFullName();
     if (schemaName.equals(memberSchema.getFullName())) {
         ...
     } else if (schemaName.equals(anotherSchema.getFullName())) {
         ...
     } else {
         ...
     }
 }</pre>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>2.0</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../oracle/kv/avro/JsonAvroBinding.html#toObject(oracle.kv.Value)">toObject</A></B>(<A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv">Value</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After doing a read operation using a <A HREF="../../../oracle/kv/KVStore.html" title="interface in oracle.kv"><CODE>KVStore</CODE></A> method, the user
 calls <code>toObject</code> with the <A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv"><CODE>Value</CODE></A> obtained from the read
 operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv">Value</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../oracle/kv/avro/JsonAvroBinding.html#toValue(oracle.kv.avro.JsonRecord)">toValue</A></B>(<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A>&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Before doing a write operation, the user calls <code>toValue</code> passing
 an object she wishes to store.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="toObject(oracle.kv.Value)"><!-- --></A><H3>
toObject</H3>
<PRE>
<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A> <B>toObject</B>(<A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv">Value</A>&nbsp;value)
                    throws <A HREF="../../../oracle/kv/avro/SchemaNotAllowedException.html" title="class in oracle.kv.avro">SchemaNotAllowedException</A>,
                           <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A></PRE>
<DL>
<DD>After doing a read operation using a <A HREF="../../../oracle/kv/KVStore.html" title="interface in oracle.kv"><CODE>KVStore</CODE></A> method, the user
 calls <code>toObject</code> with the <A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv"><CODE>Value</CODE></A> obtained from the read
 operation.
 <p>
 If necessary, this method automatically performs schema evolution, as
 described in <A HREF="../../../oracle/kv/avro/AvroCatalog.html" title="interface in oracle.kv.avro"><CODE>AvroCatalog</CODE></A>. In the context of schema evolution,
 the writer schema is the one associated internally with the <code>value</code> parameter (this association was normally made earlier when the
 value was stored), and the reader schema is the one associated with this
 binding (and was specified when the binding was created).
 <p>
 In other words, this method transforms the serialized data in the <code>value</code> parameter to conform to the schema of the <A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><CODE>JsonRecord</CODE></A> that
 is returned.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../oracle/kv/avro/AvroBinding.html#toObject(oracle.kv.Value)">toObject</A></CODE> in interface <CODE><A HREF="../../../oracle/kv/avro/AvroBinding.html" title="interface in oracle.kv.avro">AvroBinding</A>&lt;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A>&gt;</CODE><DT><B>Specified by:</B><DD><CODE><A HREF="../../../oracle/kv/ValueBinding.html#toObject(oracle.kv.Value)">toObject</A></CODE> in interface <CODE><A HREF="../../../oracle/kv/ValueBinding.html" title="interface in oracle.kv">ValueBinding</A>&lt;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A>&gt;</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - the <A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv"><CODE>Value</CODE></A> obtained from a <A HREF="../../../oracle/kv/KVStore.html" title="interface in oracle.kv"><CODE>KVStore</CODE></A> read
 operation method..  The byte array of the <A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv"><CODE>Value</CODE></A> is
 serialized Avro data, packaged in an internal format that includes a
 reference to the Avro schema
<DT><B>Returns:</B><DD>the deserialized <A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><CODE>JsonRecord</CODE></A> instance.  The <A HREF="../../../oracle/kv/avro/JsonRecord.html#getSchema()"><CODE>JsonRecord.getSchema()</CODE></A> method will return the reader schema, which is the
 schema that was specified when this binding was created.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../oracle/kv/avro/SchemaNotAllowedException.html" title="class in oracle.kv.avro">SchemaNotAllowedException</A></CODE> - if the schema associated with the
 <code>value</code> parameter is not allowed with this binding.
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if the value format is not <A HREF="../../../oracle/kv/Value.Format.html#AVRO"><CODE>Value.Format.AVRO</CODE></A>, the schema identifier embedded in the <code>value</code>
 parameter is invalid, or the serialized data cannot be parsed.</DL>
</DD>
</DL>
<HR>

<A NAME="toValue(oracle.kv.avro.JsonRecord)"><!-- --></A><H3>
toValue</H3>
<PRE>
<A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv">Value</A> <B>toValue</B>(<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A>&nbsp;object)
              throws <A HREF="../../../oracle/kv/avro/SchemaNotAllowedException.html" title="class in oracle.kv.avro">SchemaNotAllowedException</A>,
                     <A HREF="../../../oracle/kv/avro/UndefinedSchemaException.html" title="class in oracle.kv.avro">UndefinedSchemaException</A>,
                     <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A></PRE>
<DL>
<DD>Before doing a write operation, the user calls <code>toValue</code> passing
 an object she wishes to store.  The resulting <A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv"><CODE>Value</CODE></A> is then
 passed to the write operation method in <A HREF="../../../oracle/kv/KVStore.html" title="interface in oracle.kv"><CODE>KVStore</CODE></A>.
 <p>
 In the context of schema evolution, as described in <A HREF="../../../oracle/kv/avro/AvroCatalog.html" title="interface in oracle.kv.avro"><CODE>AvroCatalog</CODE></A>,
 the returned value is serialized according to the writer schema.  The
 writer schema is the one associated with the <A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><CODE>JsonRecord</CODE></A>
 <code>object</code> parameter; it is returned by <A HREF="../../../oracle/kv/avro/JsonRecord.html#getSchema()"><CODE>JsonRecord.getSchema()</CODE></A>
 and specified when creating a <A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><CODE>JsonRecord</CODE></A> object.  The writer
 schema must be one of the schemas specified when this binding was
 created.
 <p>
 In other words, this method returns serialized data that conforms to the
 schema of the given <A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><CODE>JsonRecord</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../oracle/kv/avro/AvroBinding.html#toValue(T)">toValue</A></CODE> in interface <CODE><A HREF="../../../oracle/kv/avro/AvroBinding.html" title="interface in oracle.kv.avro">AvroBinding</A>&lt;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A>&gt;</CODE><DT><B>Specified by:</B><DD><CODE><A HREF="../../../oracle/kv/ValueBinding.html#toValue(T)">toValue</A></CODE> in interface <CODE><A HREF="../../../oracle/kv/ValueBinding.html" title="interface in oracle.kv">ValueBinding</A>&lt;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro">JsonRecord</A>&gt;</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - the <A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><CODE>JsonRecord</CODE></A> instance the user wishes to
 store, or at least serialize.
<DT><B>Returns:</B><DD>the serialized object..  The byte array of the <A HREF="../../../oracle/kv/Value.html" title="class in oracle.kv"><CODE>Value</CODE></A> is
 serialized Avro data, packaged in an internal format that includes a
 reference to the Avro schema
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../oracle/kv/avro/SchemaNotAllowedException.html" title="class in oracle.kv.avro">SchemaNotAllowedException</A></CODE> - if the schema associated with the
 <code>object</code> parameter is not allowed with this binding.
<DD><CODE><A HREF="../../../oracle/kv/avro/UndefinedSchemaException.html" title="class in oracle.kv.avro">UndefinedSchemaException</A></CODE> - if the schema associated with the
 <code>object</code> parameter has not been defined using the NoSQL Database
 administration interface.  Note that when the allowed schemas for a
 binding are specified (and validate) at the time the binding is created,
 this exception is extremely unlikely and is only possible if a schema is
 mistakenly disabled after the binding is created.
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if the <code>object</code> parameter is
 invalid according to its schema, and cannot be serialized.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JsonAvroBinding.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Oracle NoSQL Database</b><br><font size=\"-1\"> version 11gR2.2.0.26</font>
      </EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../oracle/kv/avro/GenericAvroBinding.html" title="interface in oracle.kv.avro"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../oracle/kv/avro/JsonRecord.html" title="class in oracle.kv.avro"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?oracle/kv/avro/JsonAvroBinding.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JsonAvroBinding.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=1>Copyright (c) 2011, 2013 Oracle and/or its affiliates.  All rights reserved.</font> 
</BODY>
</HTML>
